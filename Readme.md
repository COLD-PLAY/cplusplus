
## C++面经
### 语言
- C和C++的区别
C是面向过程语言，而C++是面向对象。C++有引用、泛型、类
C++在C的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。

- 什么是多态
多态性(polymorphism)可以简单地概括为“**一个接口，多种方法**”，它是面向对象编程领域的核心概念。

多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。

编译时多态性（静态多态）：通过**重载函数**实现：先期联编 early binding
运行时多态性（动态多态）：通过**虚函数**实现 ：滞后联编 late binding

参数相同、有virtual关键字：多态重写；
参数相同、无virtual关键字：隐藏；与重写区分。
参数不同、有virtual关键字：隐藏；与重载区分。
参数不同、无virtual关键字：隐藏；与重载区分。

- 什么是虚函数，什么是纯虚函数
定义一个函数为虚函数，不代表函数为不被实现的函数。
**定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。**
定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须**实现这个函数。**
虚函数实现的过程是：**通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。**所以虚函数的调用时由指针所指向内存块的具体类型决定的。
**虚函数 vs 纯虚函数，如何选用？**
a. 当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。
b. 当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。

- 纯虚函数作用和实现方式
定义纯虚函数是为了实现一个**接口**，起到一个**规范**的作用，规范继承这个类的程序员必须**实现这个函数。**
应该在什么情况下使用纯虚函数？
　　1、当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；
　　2、这个方法必须在派生类（derived class）中被实现。
纯虚函数的声明，是在虚函数声明的结尾加 = 0，**没有函数体**。在派生类没有重新定义虚函数之前是**不能调用的**。

- 构造函数和析构函数可以是虚函数吗？
答案是：**构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。**

首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。

而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当**继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。**
同时防止内存泄漏，想去借助父类指针销毁子类对象的时候，不能销毁子类对象。调用基类的析构函数，导致派生类中对象申请的空间得不到释放进而发生内存泄漏。

- static 和const 的作用
其他的不重要，重要的是static 修饰全局变量时**并未改变**其存储位置及生命周期，而是改变了其**作用域**，使**当前文件外的源文件无法访问**该变量。好处如下：
（1）不会被其他文件所访问，修改
（2）其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用。而普通全局变量只要定义了，任何地方都能使用，使用前需要声明所有的.c文件，只能定义一次普通全局变量，但是可以声明多次（外部链接）。注意：全局变量的作用域是全局范围，但是在某个文件中使用时，必须先声明。
用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。
静态数据成员的类型**可以是所属类的类型**，而普通数据成员则不可以。普通数据成员的只能声明为所属类类型的**指针或引用**。（因为是存在静态存储区的，不属于某个对象，不然某个对象中含有某个对象的全部内容就套娃了）
**不可以同时用const和static修饰成员函数。**
C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数**const this***。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。
我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。

const的作用：
1.限定变量为不可修改。
2.限定成员函数不可以修改任何数据成员。
3.const与指针：
    const char *p 表示 指向的内容不能改变。
    char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。

- new 和malloc 的区别
new是**运算符**，malloc()是一个**库函数**；
new会调用**构造函数**，malloc不会；
new返回指定类型指针，malloc返回**void\***指针，需要强制类型转换；
new会自动计算需分配的空间，malloc不行；
new可以被**重载**，malloc不能。

- C++的内存分区
栈区（stack）：主要存放函数参数以及局部变量，由系统自动分配释放。
堆区（heap）：由用户通过 malloc/new 手动申请，手动释放。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
全局/静态区：存放全局变量、静态变量；程序结束后由系统释放。
字符串常量区：字符串常量就放在这里，程序结束后由系统释放。
代码区：存放程序的二进制代码。

- vector、map、multimap、unordered_map、unordered_multimap的底层数据结构，以及几种map容器如何选择？
底层数据结构：
vector基于数组，map、multimap基于红黑树，unordered_map、unordered_multimap基于哈希表。
根据应用场景进行选择：
map/unordered_map 不允许重复元素
multimap/unordered_multimap 允许重复元素
map/multimap 底层基于红黑树，元素自动有序，且插入、删除效率高
unordered_map/unordered_multimap 底层基于哈希表，故元素无序，查找效率高。

- const与#define的区别
1.编译器处理方式 
define – 在预处理阶段进行替换 
const – 在编译时确定其值

2.类型检查 
define – 无类型，不进行类型安全检查，可能会产生意想不到的错误 
const – 有数据类型，编译时会进行类型检查

3.内存空间 
define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大 
const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝

4.其他 
在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。 
宏替换只作替换，不做计算，不做表达式求解。

- 悬空指针与野指针区别
悬空指针：当所指向的对象被释放或者收回，但是没有让指针指向NULL；
野指针：那些未初始化的指针；
```C++
{
   char *dp = NULL;
   {
       char c;
       dp = &c;
   } 
  //变量c释放，dp变成空悬指针
}
void func()
{
    char *dp = (char *)malloc(A_CONST);
    free(dp);         //dp变成一个空悬指针
    dp = NULL;        //dp不再是空悬指针
    /* ... */
}
```
```C++
int func()
{
    char *dp;//野指针，没有初始化
    static char *sdp;//非野指针，因为静态变量会默认初始化为0
}
```

- struct与class的区别?
本质区别是访问的默认控制：默认的继承访问权限，class是private，struct是public；

- sizeof和strlen的区别?
1. 功能不同：
sizeof是操作符，参数为任意类型，主要计算类型占用内存大小。
strlen()是函数，其函数原型为：extern unsigned int strlen(char \*s);其参数为char*,strlen只能计算以"\0"结尾字符串的长度，计算结果不包括"\0"。

2. 参数不同：
当将字符数组作为sizeof()的参数时，计算字符数组占用内存大小；当将字符数组作为strlen()函数，字符数组转化为char*。因为sizeof的参数为任意类型，而strlen（）函数参数只能为char*，当参数不是char\*必须转换为char\*。

- 32位，64位系统中，各种常用内置数据类型占用的字节数?
除*与long 不同其余均相同。
char 1, short int 2, int 4, unsigned int 4, float 4, double 8, long 4, unsigned long 4, long long 8
char 1, short int 2, int 4, unsigned int 4, float 4, double 8, long 8, unsigned long 8, long long 8
unsigned long本质上就是void*指针的表示方式

- virtual,inline,decltype,volatile,static,const关键字的作用?使用场景?
inline：在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了inline修饰符，表示为内联函数。
```C++
#include <stdio.h>
//函数定义为inline即:内联函数
inline char* dbtest(int a) {
    return (i % 2 > 0) ? "奇" : "偶";
} 

int main()
{
   int i = 0;
   for (i=1; i < 100; i++) {
       printf("i:%d    奇偶性:%s /n", i, dbtest(i));    
   }
}//在for循环的每个dbtest(i)的地方替换成了 (i % 2 > 0) ? "奇" : "偶"，避免了频繁调用函数，对栈内存的消耗
```
decltype:从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量。还有可能是函数的返回类型为某表达式的的值类型。
```C++
int f() {
	return 0;
}

void decltypeTest() {
	decltype(f()) a = 2;
	cout << a << endl;
}
```
volatile：volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就**不再进行优化**，从而可以提供对特殊地址的稳定访问。突出一个**不优化**。volatile 可以保证对特殊地址的稳定访问

static:
1. 隐藏
在变量和函数名前面如果未加static，则它们是全局可见的。加了static，就会对**其它源文件隐藏**，利用这一特性可以在**不同的文件中定义同名函数和同名变量**，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。

2. static变量中的记忆功能和全局生存期
存储在静态数据区的变量会在**程序刚开始运行时就完成初始化**，也是**唯一**的一次初始化。共有两种变量存储在静态存储区：**全局变量和static变量**，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来**隐藏**的。PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是**其作用域仍与自动变量相同**，只能在定义该变量的函数内使用该变量。退出该函数后，**尽管该变量还继续存在，但不能使用它。**

```C++
＃include <stdio.h>

int fun(){
    static int count = 10;       //在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a
    return count--;              //就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    

}

int count = 1;

int main(void)
{
     printf("global\t\tlocal static\n");
     for(; count <= 10; ++count)
               printf("%d\t\t%d\n", count, fun());
     return 0;
}
```
---基于以上两点可以得出一个结论：把**局部变量**改变为**静态变量**后是**改变了它的存储方式即改变了它的生存期**。把**全局变量**改变为**静态变量**后是**改变了它的作用域，限制了它的使用范围**。因此static 这个说明符在不同的地方所起的作用是不同的。

3. static的第三个作用是默认初始化为0（static变量）
**最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。**

4. static的第四个作用：C++中的类成员声明static（有些地方与以上作用重复）
在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：

(1)类的静态成员函数是属于**整个类而非类的对象**，所以它**没有this指针**，这就导致了它仅能访问类的**静态数据和静态成员函数**。

(2)不能将静态成员函数定义为虚函数（**同样是由于没有this指针**）。

(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针，函数地址类型是一个“**non-member函数指针**”（member函数指针多了一个**adj**用于指明this指针偏移）。

(4)由于静态成员函数没有this指针，所以就差不多等同于non-member函数，结果就产生了一个意想不到的好处：成为一个**callback函数**，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。（这条没遇见过）

(5)static并没有增加程序的时空开销，相反她还**缩短了子类对父类静态成员的访问时间**，节省了子类的内存空间。

(6)静态数据成员在<定义或说明>时前面加关键字static。

(7)静态数据成员是静态存储的，所以**必须对它进行初始化**。（程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误），**这是因为类中的静态成员变量仅仅是声明，暂时不需分配内存**，甚至可以这样写代码：
```C++
//a.cpp
class B; //这里我们使用前置声明，完全不知道B是什么样子
class A {
public:
	static B bb;//声明了一个类型为B的静态成员，在这里编译器并未给bb分配内存。
    //因为仅仅是声明bb,所以编译器并不需要知道B是什么样子以及要给其对应的对象分配多大的空间。
    //所以使用前置声明"class B"就可以保证编译通过。
};
```

(8)静态成员初始化与一般数据成员初始化不同:
初始化在类体外进行，而**前面不加static**，以免与一般静态变量或对象相混淆；
初始化时不加该成员的访问权限控制符private，public等；
初始化时使用作用域运算符来标明它所属类；

所以我们得出静态数据成员初始化的格式：
<数据类型><类名>::<静态数据成员名>=<值>

(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。

- 深拷贝和浅拷贝的区别? **记住默认浅拷贝就完了**
1. 什么时候用到拷贝构造函数?
    a. 一个对象以值传递的方式传入函数体；
    b. 一个对象以值传递的方式从函数返回；
    c. 一个对象需要通过另外一个对象进行初始化。
    如果在类中没有显示地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的位拷贝，又称浅拷贝。
2. 是否应该自定义拷贝函数?
    自定义拷贝构造函数是一种良好的编程风格，它可以组织编译器形成默认的拷贝构造函数，提高源码效率。
3. 什么叫深拷贝？什么是浅拷贝？两者异同？
    如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。
4. 深拷贝好还是浅拷贝好？
    如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。

- 派生类中构造函数，析构函数调用顺序？
构造函数：“先基后派”；析构函数：“先派后基”。

- C++类中数据成员初始化顺序？
1.成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。
2.如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。
3.类中const成员常量必须在构造函数初始化列表中初始化。
4.类中static成员变量，只能在类内外初始化(同一类的所有实例共享静态成员变量)。

初始化顺序：（先基后派）
1） 基类的静态变量或全局变量
2） 派生类的静态变量或全局变量
3） 基类的成员变量
4） 派生类的成员变量

- 结构体内存对齐问题？结构体/类大小的计算？
内存对齐是**看类型，而不是看总的字节数**，即每个成员相对于这个结构体变量地址的偏移量正好是该成员**类型所占字节的整数倍**。为了对齐数据，可能必须在上一个数据结束和下一个数据开始的地方插入一些没有用处字节。
最终占用字节数为成员类型中最大占用字节数的整数倍。
**一般的结构体成员按照默认对齐字节数递增或是递减的顺序排放，会使总的填充字节数最少。**

- 联合体的大小计算：
联合体所占的空间不仅取决于最宽成员，还跟所有成员有关系，即其大小必须满足两个条件：
1)大小足够**容纳最宽的成员**；
2)大小能被其包含的**所有基本数据类型的大小所整除**。
```C++
union U1  
{  
    int n;  
    char s[11];  
    double d;  
};  //16，char s[11]按照char=1可以整除
  
union U2  
{  
    int n;  
    char s[5];  
    double d;  
};  //8
```

- static_cast, dynamic_cast, const_cast, reinpreter_cast的区别？ 
补充：static_cast与dynamic_cast

cast发生的时间不同，一个是static**编译时**，一个是runtime**运行时**；
static_cast是相当于C的**强制类型转换**，用起来可能有一点危险，不提供运行时的检查来确保转换的安全性。
dynamic_cast用于转换指针和和引用，不能用来转换对象 ——主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。在多态类型之间的转换主要使用dynamic_cast，因为类型提供了运行时信息。

- 智能指针
1. 智能指针是在 <memory> 头文件中的std命名空间中定义的，该指针用于确保程序不存在内存和资源泄漏且是异常安全的。它们对RAII“获取资源即初始化”编程至关重要，RAII的主要原则是为将任何堆分配资源（如动态分配内存或系统对象句柄）的所有权提供给其析构函数包含用于删除或释放资源的代码以及任何相关清理代码的堆栈分配对象。大多数情况下，当初始化原始指针或资源句柄以指向实际资源时，会立即将指针传递给智能指针。
2. 智能指针的设计思想：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。
3. unique_ptr只允许基础指针的一个所有者。unique_ptr小巧高效；大小等同于一个指针且支持右值引用，从而可实现快速插入和对STL集合的检索。
4. shared_ptr采用引用计数的智能指针，主要用于要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时）的情况。当所有的shared_ptr所有者超出了范围或放弃所有权，才会删除原始指针。大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块。最安全的分配和使用动态内存的方法是调用make_shared标准库函数，此函数在动态分配内存中分配一个对象并初始化它，返回对象的shared_ptr。

- 计算类大小例子
class A {};: sizeof(A) = 1;
class A { virtual Fun(){} };: sizeof(A) = 4(32位机器)/8(64位机器);
class A { static int a; };: sizeof(A) = 1;
class A { int a; };: sizeof(A) = 4;
class A { static int a; int b; };: sizeof(A) = 4;

类中用static声明的成员变量不计算入类的大小中，因为static data不是实例的一部分。static的属于全局的，他不会占用类的存储，他有专门的地方存储 （全局变量区）

- 大端与小端的概念？各自的优势是什么？
大端：低字节存在高地址端
小端：低字节存在低地址端

对于0x12345678这个数的存储：
1)大端模式：
低地址 -----------------> 高地址
0x12 | 0x34 | 0x56 | 0x78

2)小端模式：
低地址 ------------------> 高地址
0x78 | 0x56 | 0x34 | 0x12

- C++中*和&同时使用是什么意思？
```C++
template<typename T>
void insertFront(Node<T>* &head, T item);
/*
上面是一个函数的声明，其中第一个参数*和&分别是什么意思？
head是个指针，前面为什么加个&
因为想要修改head，指针变量的引用
*/
```

- C++ vector和list的区别
1. vector和数组类似，拥有一段连续的内存空间，且起始地址不变。因此能高效随机存取，时间复杂度O(1)；但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为O(n)；另外，当数组中存储空间不够时，会当前容量\*1.5或者\*2重新申请一块内存空间并进行内存拷贝。

2. list是双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，存取时间复杂度为O(n)，但由于是链表，所以能高效进行插入和删除。

- 定义一个空类 编译器做了哪些操作？
如果只是声明一个空类，编译器会自动生成一个默认构造函数、一个拷贝默认构造函数、一个拷贝默认赋值操作符和一个默认析构函数。这些函数只有在第一次被调用时才会被编译器创建，所有这些函数都是inline和public的。
```C++
class Empty {};

// 等价于
class Empty {
public:
    Empty();
    Empty(const Empty&);
    ~Empty();
    Empty& operator=(const Empty&);
};
```

- 什么情况下，类的析构函数应该声明为虚函数？为什么？
基类指针可以向派生类的对象（多态性），如果删除该指针delete []p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。

- 哪些函数不能成为虚函数？
不能被继承的函数和不能被重写的函数。

1）普通函数

普通函数不属于成员函数，是不能被继承的。普通函数只能被重载，不能被重写，因此声明为虚函数没有意义。因为编译器会在编译时绑定函数。

而多态体现在运行时绑定。通常通过基类指针指向子类对象实现多态。

2）友元函数

友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

3）构造函数

首先说下什么是构造函数，构造函数是用来初始化对象的。假如子类可以继承基类构造函数，那么子类对象的构造将使用基类的构造函数，而基类构造函数并不知道子类的有什么成员，显然是不符合语义的。从另外一个角度来讲，多态是通过基类指针指向子类对象来实现多态的，在对象构造之前并没有对象产生，因此无法使用多态特性，这是矛盾的。因此构造函数不允许继承。

4）内联成员函数

我们需要知道内联函数就是为了在代码中直接展开，减少函数调用花费的代价。也就是说内联函数是在编译时展开的。而虚函数是为了实现多态，是在运行时绑定的。因此显然内联函数和多态的特性相违背。

5）静态成员函数

首先静态成员函数理论是可继承的。但是静态成员函数是编译时确定的，无法动态绑定，不支持多态，因此不能被重写，也就不能被声明为虚函数。

- 编写一个有构造函数，析构函数，赋值函数，和拷贝构造函数的String类
```C++
// String.h
class String {
public:
    String(const char* str);
    String(const String& other);
    ~String();
    String& operator=(const String& other);
private:
    char* data_;
}

// String.cpp
#include "String.h"
String::String(const char* str) {
    if (str == nullptr) {
        data_ = new char[1];
        *data_ = '\0';
    } else {
        int n = strlen(str);
        data_ = new char[n + 1];
        strcpy(data_, str);
    }
}

String::String(const String& other) {
    int n = strlen(other.data_);
    data_ = new char[n + 1];
    strcpy(data_, other.data_);
}

String::~String() {
    delete[] data_;
}

String::String& operator=(const String& other) {
    if (&other == *this) return *this;
    delete[] data_;
    int n = strlen(other.data_);
    data_ = new char[n + 1];
    strcpy(data_, other.data_);
    return *this;
}

```

- vector扩容原理说明
新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；
对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；
初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；
不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。
vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。
为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好。

- 内联函数和宏定义的区别
1.宏定义不是函数，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率。
内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。如果内联函数的函数体过大，编译器会自动      的把这个内联函数变成普通函数。
2. 宏定义是在预处理的时候把所有的宏名用宏体来替换，简单的说就是字符串替换
内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率
3. 宏定义是没有类型检查的，无论对还是错都是直接替换
内联函数在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等
4. 宏定义和内联函数使用的时候都是进行代码展开。不同的是宏定义是在预编译的时候把所有的宏名替换，内联函数则是在编译阶段把所有调用内联函数的地方把内联函数插入。这样可以省去函数压栈退栈，提高了效率

- 内联函数与普通函数的区别
1. 内联函数和普通函数的参数传递机制相同，但是编译器会在每处调用内联函数的地方将内联函数内容展开，这样既避免了函数调用的开销又没有宏机制的缺陷。
2. 普通函数在被调用的时候，系统首先要到函数的入口地址去执行函数体，执行完成之后再回到函数调用的地方继续执行，函数始终只有一个复制。
内联函数不需要寻址，当执行到内联函数的时候，将此函数展开，如果程序中有N次调用了内联函数则会有N次展开函数代码。
3. 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句。如果内联函数函数体过于复杂，编译器将自动把内联函数当成普通函数来执行。

- vector中v[i]与v.at(i)的区别
```C++
void f(vector<int>& v) {
    v[5]; // A
    v.at(5); // B
}
```
如果v非空，A行和B行没有任何区别。如果v为空，B行会抛出std::out_of_range异常，A行的行为未定义。
c++标准不要求vector<T>::operator[\]进行下标越界检查，原因是为了效率，总是强制下标越界检查会增加程序的性能开销。设计vector是用来代替内置数组的，所以效率问题也应该考虑。不过使用operator[]就要自己承担越界风险了。
如果需要下标越界检查，请使用at。但是请注意，这时候的性能也是响应的会受影响，因为越界检查增加了性能的开销。

- C++中调用C的函数
解决方案一：
若calc中代码量很小，或代码是自己写的可以直接利用c++兼容c的特性，把calc.c改成calc.cpp。即可编译。

解决方案二：
在calc.h中的每个函数最前面添加：extern "C"
比较简单的方案是：
```C++
extern "C" { 
    void fun1(int arg1); 
    void fun2(int arg1, int arg2); 
    void fun3(int arg1, int arg2, int arg3); 
}
```

若不确定当前编译环境是C还是C++，可以这样：
```C++
#ifdef __cplusplus
extern "C" {
#endif

void fun1(int arg1);
void fun2(int arg1, int arg2);
void fun3(int arg1, int arg2, int arg3);

#ifdef __cplusplus
}
#endif
```

解决方法三：
若别人已经写好的头文件，我们无法修改，怎么办？重写一个专门被c++用的头文件即可。
例：编写头文件 cpp_calc.h

```c++
extern "C" {
#include "calc.h"; 
}
```

- 指针常量与常量指针
指针常量：指针不能改变指向，但可以改变指针指向对象的内容
常量指针：指针可以改变指向，但不能改变指针指向对象的内容
```C++
int a = 10;
int* const p = &a; // 指针常量
const int* p = &a; // 常量指针
```

- 防止头文件被重复包含
```C++
#ifndef ...
#define ...
#endif

// or
#pragma once
```

### 计算机网络
- 五层协议的体系结构
1. 应用层
应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。
2. 运输层
运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
3. 网络层
网络层(network layer)负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。
这里要注意：**不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混**。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。
网络层的另一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。
这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.
互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。
4. 数据链路层
数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装程帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。
在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。
控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。
5. 物理层
在物理层上所传送的数据单位是比特。
物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。
在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。
![](https://img-blog.csdnimg.cn/2021010409370574.gif)

- TCP三次握手和四次挥手
1. 为什么要三次握手？
第一次握手，发送方发送一个带`SYN=j`的数据包
第二次握手，接收方发送一个`ACK=j+1,SYN=k`的数据包
第三次握手，发送方发送一个`ACK=k+1`的数据包，就这样建立起来了连接
因为发送方和接收方都需要确认双方都能正常接收和发送：
第一次握手：Client 什么都不能确认；Server 确认了对方发送正常
第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常
第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常
所以三次握手就能确认双发收发功能都正常，缺一不可。
2. 为什么要四次挥手？
任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

- 停止等待协议
1. 无差错情况，发送方发送分组，接收方在规定时间内收到，并且回复确认，发送方再次发送
2. 出现差错情况（超时重传），停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。
3. 确认丢失和确认迟到
a. 确认丢失：确认消息在传输过程中丢失
当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：
1）丢弃这个重复的M1消息，不向上层交付。
2）向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。

b. 确认迟到：确认消息在传输过程中迟到
A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：
1）A收到重复的确认后，直接丢弃。
2）B收到重复的M1后，也直接丢弃重复的M1。

- 自动重传请求 ARQ 协议
停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。
优点： 简单
缺点： 信道利用率低

- 连续ARQ协议
连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。
优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。
缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

- 滑动窗口
TCP 利用滑动窗口实现流量控制的机制。
滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。
TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小

- 流量控制
TCP 利用滑动窗口实现流量控制。
流量控制是为了控制发送方发送速率，保证接收方来得及接收。
接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

- 拥塞控制
在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。
为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。
TCP的拥塞控制采用了四种算法，即**慢开始 、 拥塞避免 、快重传 和 快恢复。**在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。
1. 慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
2. 拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.
3. 快重传与快恢复：
在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。  当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

