
#### C++面经
### 语言
- C和C++的区别
C是面向过程语言，而C++是面向对象。C++有引用、泛型、类
C++在C的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。

- 什么是多态
多态性(polymorphism)可以简单地概括为“**一个接口，多种方法**”，它是面向对象编程领域的核心概念。

多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。

编译时多态性（静态多态）：通过**重载函数**实现：先期联编 early binding
运行时多态性（动态多态）：通过**虚函数**实现 ：滞后联编 late binding

参数相同、有virtual关键字：多态重写；
参数相同、无virtual关键字：隐藏；与重写区分。
参数不同、有virtual关键字：隐藏；与重载区分。
参数不同、无virtual关键字：隐藏；与重载区分。

- 什么是虚函数，什么是纯虚函数
定义一个函数为虚函数，不代表函数为不被实现的函数。
**定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。**
定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须**实现这个函数。**
虚函数实现的过程是：**通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。**所以虚函数的调用时由指针所指向内存块的具体类型决定的。
**虚函数 vs 纯虚函数，如何选用？**
a. 当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。
b. 当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。

- 纯虚函数作用和实现方式
定义纯虚函数是为了实现一个**接口**，起到一个**规范**的作用，规范继承这个类的程序员必须**实现这个函数。**
应该在什么情况下使用纯虚函数？
　　1、当想在基类中抽象出一个方法，且该基类只做能被继承，而不能被实例化；
　　2、这个方法必须在派生类（derived class）中被实现。
纯虚函数的声明，是在虚函数声明的结尾加 = 0，**没有函数体**。在派生类没有重新定义虚函数之前是**不能调用的**。

- 构造函数和析构函数可以是虚函数吗？
答案是：**构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。**

首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。

而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当**继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。**
同时防止内存泄漏，想去借助父类指针销毁子类对象的时候，不能销毁子类对象。调用基类的析构函数，导致派生类中对象申请的空间得不到释放进而发生内存泄漏。

- static 和const 的作用
其他的不重要，重要的是static 修饰全局变量时**并未改变**其存储位置及生命周期，而是改变了其**作用域**，使**当前文件外的源文件无法访问**该变量。好处如下：
（1）不会被其他文件所访问，修改
（2）其他文件中可以使用相同名字的变量，不会发生冲突。对全局函数也是有隐藏作用。而普通全局变量只要定义了，任何地方都能使用，使用前需要声明所有的.c文件，只能定义一次普通全局变量，但是可以声明多次（外部链接）。注意：全局变量的作用域是全局范围，但是在某个文件中使用时，必须先声明。
用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针。
静态数据成员的类型**可以是所属类的类型**，而普通数据成员则不可以。普通数据成员的只能声明为所属类类型的**指针或引用**。（因为是存在静态存储区的，不属于某个对象，不然某个对象中含有某个对象的全部内容就套娃了）
**不可以同时用const和static修饰成员函数。**
C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数**const this***。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。
我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。

const的作用：
1.限定变量为不可修改。
2.限定成员函数不可以修改任何数据成员。
3.const与指针：
    const char *p 表示 指向的内容不能改变。
    char * const p，就是将P声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变。

- new 和malloc 的区别
new是**运算符**，malloc()是一个**库函数**；
new会调用**构造函数**，malloc不会；
new返回指定类型指针，malloc返回**void\***指针，需要强制类型转换；
new会自动计算需分配的空间，malloc不行；
new可以被**重载**，malloc不能。

- C++的内存分区
栈区（stack）：主要存放函数参数以及局部变量，由系统自动分配释放。
堆区（heap）：由用户通过 malloc/new 手动申请，手动释放。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
全局/静态区：存放全局变量、静态变量；程序结束后由系统释放。
字符串常量区：字符串常量就放在这里，程序结束后由系统释放。
代码区：存放程序的二进制代码。

- vector、map、multimap、unordered_map、unordered_multimap的底层数据结构，以及几种map容器如何选择？
底层数据结构：
vector基于数组，map、multimap基于红黑树，unordered_map、unordered_multimap基于哈希表。
根据应用场景进行选择：
map/unordered_map 不允许重复元素
multimap/unordered_multimap 允许重复元素
map/multimap 底层基于红黑树，元素自动有序，且插入、删除效率高
unordered_map/unordered_multimap 底层基于哈希表，故元素无序，查找效率高。

- const与#define的区别
1.编译器处理方式 
define – 在预处理阶段进行替换 
const – 在编译时确定其值

2.类型检查 
define – 无类型，不进行类型安全检查，可能会产生意想不到的错误 
const – 有数据类型，编译时会进行类型检查

3.内存空间 
define – 不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中会有多个拷贝，消耗内存大 
const – 在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝

4.其他 
在编译时， 编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。 
宏替换只作替换，不做计算，不做表达式求解。
